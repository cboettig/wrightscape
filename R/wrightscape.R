#wrightscape.R

# update with new data
update.wrighttree <- function(ws, data){
	wrightscape(data=data, tree=ws$tree, regimes=ws$regimes, Xo=ws$Xo, alpha=ws$alpha, theta=ws$theta, sigma=ws$sigma)
}

wrightscape <- function(data, tree, regimes, alpha=1, sigma=1, theta = NULL, Xo = NULL){

	# data should be a numeric instead of data.frame.  Should check node names or node order too!
	dataIn <- data
	if(is(data, "data.frame") | is(data, "list")) { 
		data <- data[[1]]
		if( !is(data, "numeric")) {stop("data should be data frame or numeric") }
	}

	# regimes should be a factor instead of data.frame
	regimesIn <- regimes
	if(is(regimes, "data.frame")) { 
		regimes <- regimes[[1]]
		if( !is(regimes, "factor")) {stop("unable to interpret regimes") }
	}


	if(is.null(Xo)){ Xo <- mean(data, na.rm=TRUE) }
	data[is.na(data)] = 0 


	ancestor <- as.numeric(tree@ancestors)
	ancestor[is.na(ancestor)] = 0 
	ancestor <- ancestor-1  # C-style indexing

	## ouch gives cumulative time, not branch-length!!
	anc <- as.integer(tree@ancestors[!is.na(tree@ancestors)])
	lengths <- c(0, tree@times[!is.na(tree@ancestors)] - tree@times[anc] )
	branch_length <- lengths/max(tree@times)

	
	n_nodes <- length(branch_length)
	n_regimes <- length(levels(regimes))

	if(length(alpha) == 1){ alpha <- rep(alpha, n_regimes) }
	if(is.null(theta)) { theta <- rep(Xo, n_regimes) }
	if(length(sigma) == 1) { sigma <- rep(sigma, n_regimes) }

	levels(regimes) <- 1:n_regimes
	regimes <- as.integer(regimes)-1  # convert to C-style indexing


	o<- .C("fit_model",
		as.double(Xo),
		as.double(alpha),
		as.double(theta),
		as.double(sigma),
		as.integer(regimes),
		as.integer(ancestor),
		as.double(branch_length),
		as.double(data),
		as.integer(n_nodes),
		as.integer(n_regimes),
		double(1)
	  )

	output <- list(data=dataIn, tree=tree, regimes=regimesIn, loglik=o[[11]], Xo = o[[1]], alpha = o[[2]], theta =  o[[3]], sigma = o[[4]]  )  
	class(output) <- "wrighttree"
	output
}


simulate.wrighttree <- function(ws){
	simulate_wrightscape(tree=ws$tree, regimes=ws$regimes, Xo=ws$Xo, alpha=ws$alpha, theta=ws$theta, sigma=ws$sigma)
}

simulate_wrightscape <- function(tree, regimes, Xo, alpha, theta, sigma){

	# regimes should be a factor instead of data.frame
	regimesIn <- regimes
	if(is(regimes, "data.frame")) { 
		regimes <- regimes[[1]]
		if( !is(regimes, "factor")) {stop("unable to interpret regimes") }
	}

	ancestor <- as.numeric(tree@ancestors)
	ancestor[is.na(ancestor)] = 0 
	ancestor <- ancestor-1  # C-style indexing

	## ouch gives cumulative time, not branch-length!!
	anc <- as.integer(tree@ancestors[!is.na(tree@ancestors)])
	lengths <- c(0, tree@times[!is.na(tree@ancestors)] - tree@times[anc] )
	branch_length <- lengths/max(tree@times)

	n_nodes <- length(branch_length)
	n_regimes <- length(levels(regimes))
	n_tips <- (n_nodes+1)/2

	levels(regimes) <- 1:n_regimes
	regimes <- as.integer(regimes)-1  # convert to C-style indexing

	seed <- runif(1)*2^16

	o<- .C("simulate_model",
		as.double(Xo),
		as.double(alpha),
		as.double(theta),
		as.double(sigma),
		as.integer(regimes),
		as.integer(ancestor),
		as.double(branch_length),
		double(n_nodes),
		as.integer(n_nodes),
		as.integer(n_regimes),
		double(1), 
		as.double(seed)
	  )

	simdata <- data.frame(o[[8]], row.names = tree@nodes)
	

	output <- list(rep.1=simdata, tree=tree, regimes=regimesIn, loglik=o[[11]], alpha = o[[2]], theta =  o[[3]], sigma = o[[4]]  )  
	class(output) <- "wrighttree"
	output
}


LR_bootstrap <- function(true_model, test_model, nboot = 200){
# Bootstraps the likelihood ratio statistic using boot function
# Args:
#		true_model -- is used to generated the simulated data.  Must be a fitted hansentree or browntree
#		test_model -- is another fitted model whose likeihood will also be evaluated on the data
#		nboot -- is the number of bootstrap replicates to do.  Defaults to 200
#	Returns:
#		boot object that can be fed into boot.ci to 
#			generate confidence intervals, etc using the boot package

	get_loglik <- function(model){
		if(is(model, "ouchtree") ) loglik = model@loglik 
		else loglik = model$loglik
		loglik
	}
	get_data <- function(model){
		if(is(model, "ouchtree") ) data = model@data 
		else data = model$data
		data
	}

	orig_diff <- -2*( get_loglik(true_model) - get_loglik(test_model))
	orig_data <- get_data(true_model)

	statisticfn <- function(data, ...){
	# function required by boot fn that will be boostrapped
	# Args: 
	#		data is data generated by a simulation, 
	#		... is the test_model
	# Returns 
	#		the likelihood ratio statistic: 2*(log(null) - log(test) )
		test <- update(test_model, data=data)
		true <- update(true_model,data=data)
		-2*(get_loglik(true) - get_loglik(test))
	}

	rangendat <- function(d, p){
	# simulate using model specified as mle, the true model
		out <- simulate(p)
		out$rep.1
	}

	boot.out <- boot(	data=orig_data, 
						statistic=statisticfn, 
						R=nboot, 
						sim="parametric", 
						ran.gen=rangendat, 
						mle=true_model, 
						object=test_model)
}

bootstrap.wrighttree <- function(model, nboot = 200, fit=TRUE)
{
# Bootstraps the likelihood ratio statistic using boot function.  Should give bootstraps for all parameters!!!!
# Args:
#		model -- is used to generated the simulated data.  Must be a fitted hansentree or browntree
#		nboot -- is the number of bootstrap replicates to do.  Defaults to 200
#	Returns:
#		boot object -- can be fed into boot.ci to generate confidence intervals, etc 
#			using the boot package

	simdata <- simulate(model)
	refit_model <- update(model, data=simdata)
}



choose_model <- function(model_list, nboot=200){
	LR <- lapply( 1:(length(model_list)-1),
					 function(i) LR_bootstrap( model_list[[i]], model_list[[i+1]], nboot )
		  		   )
	p_vals <- sapply( 1:(length(model_list)-1),
			function(i)  sum( LR[[i]]$t < LR[[i]]$t0 )/length(LR[[i]]$t)
		  )
	print(p_vals)
	LR	
}

pretty_plot <- function(LR, main=""){
	xlim = 1.1*c(min( LR$t, LR$t0), max( LR$t, LR$t0) )
	hist(LR$t, col="lightblue", border="white", xlab="Likelihood Ratio", cex.axis=1.6, cex.lab=1.6, main=main, xlim=xlim)
	abline(v=LR$t0, lwd=4, lty=2, col="darkblue")
	p_val <- 1-sum(LR$t < LR$t0)/length(LR$t)  
	text(LR$t0, 0.5*par()$yaxp[2], paste("p = ", round(p_val, digits=3)), cex=1.6)   # halfway up the vert line
}

anoles_test <- function(nboot=20){
#	require(phyloniche)
	require(wrightscape)
	data(bimac)
	tree <- with(bimac,ouchtree(nodes=node,ancestors=ancestor,times=time/max(time),labels=species))
	bm <- brown(log(bimac['size']), tree)
	ou1 <- hansen(log(bimac['size']), tree, bimac['OU.1'], 1, 1)
	ws1 <- wrightscape(log(bimac['size']), tree, bimac['OU.1'], 1, 1)
	ou2 <- hansen(log(bimac['size']), tree, bimac['OU.LP'], 1, 1)
	ws2 <- wrightscape(log(bimac['size']), tree, bimac['OU.LP'], (ou2@sqrt.alpha)^2, ou2@sigma)

	model_list <- list(bm = bm, ws1 = ws1, ou2 = ou2, ws2 = ws2)
	LR <- choose_model(model_list, 100)
	pretty_plot(LR[[3]])

	
# some "by hand" methods available
	LR <- LR_bootstrap(ou2, ws2, n=100)
	plot(LR)
	x <- simulate(ws2)
	up_w <- update(ws2, x$rep.1)
	up_h <- update(ou2, x$rep.1)


}


sedges_test <- function(nboot=20){
#	require(phyloniche)
	source("/home/cboettig/Documents/ucdavis/research/phylotrees/code/Comparative-Phylogenetics/R/data_formats.R")
	require(wrightscape)
	require(maticce)
	data(carex)
	attach(carex)

	treedata <- ape2ouch_all(ovales.tree, ovales.data)
	ou2_regimes <- paintBranches(list(ovales.nodes[[2]]), treedata$tree)
	ou1_regimes <- as.factor(rep(1, length(ou2_regimes) ))
	names(ou1_regimes) <- names(ou2_regimes)

# Fit the models
	bm <- brown(treedata$data, treedata$tree)
	ws1 <- wrightscape(treedata$data, treedata$tree, ou1_regimes, 1, 1)
	ou2 <- hansen(treedata$data, treedata$tree, ou2_regimes, 1, 1)
	ws2 <- wrightscape(treedata$data, treedata$tree, ou2_regimes, (ou2@sqrt.alpha)^2, ou2@sigma)

	model_list <- list(bm = bm, ws1 = ws1, ou2 = ou2, ws2 = ws2)
	LR <- choose_model(model_list, 100)
	pretty_plot(LR[[1]], main="support for OU over BM")
	pretty_plot(LR[[3]], main="support for differential selective strength")


		
	}







